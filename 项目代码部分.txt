# Project Export
# Export Date: 2025-05-04 13:33:14
# Project Root: D:\Desktop\LLMSystem

================================================================================
PROJECT STRUCTURE:
================================================================================

LLMSystem/
├── .gitignore
├── .junie/
├── .mvn/
│   └── wrapper/
├── knowledge-files/
├── pom.xml
└── src/
    ├── main/
    │   ├── java/
    │   │   └── com/
    │   │       └── example/
    │   │           └── chatbot/
    │   │               ├── LlmSystemApplication.java
    │   │               ├── config/
    │   │               │   ├── PromptProperties.java
    │   │               │   ├── SecurityConfig.java
    │   │               │   └── WebClientConfig.java
    │   │               ├── controller/
    │   │               │   ├── ChatBotController.java
    │   │               │   ├── ChatController.java
    │   │               │   ├── ConfigController.java
    │   │               │   ├── KnowledgeController.java
    │   │               │   └── UserController.java
    │   │               ├── model/
    │   │               │   ├── Chat.java
    │   │               │   ├── Document.java
    │   │               │   ├── Segment.java
    │   │               │   └── User.java
    │   │               ├── repository/
    │   │               │   ├── ChatRepository.java
    │   │               │   ├── DocumentRepository.java
    │   │               │   ├── SegmentRepository.java
    │   │               │   └── UserRepository.java
    │   │               ├── service/
    │   │               │   ├── ChatService.java
    │   │               │   ├── EmbeddingService.java
    │   │               │   ├── IntentRecognitionService.java
    │   │               │   ├── KnowledgeService.java
    │   │               │   ├── LLMService.java
    │   │               │   └── UserService.java
    │   │               └── util/
    │   │                   ├── DocumentParser.java
    │   │                   └── TextUtils.java
    │   └── resources/
    │       └── static/
    │           ├── app.js
    │           ├── index.html
    │           └── styles.css
    └── test/
        └── java/
            └── com/
                └── example/
                    └── chatbot/
                        ├── LlmSystemApplicationTests.java
                        └── service/
                            └── IntentRecognitionServiceTest.java


================================================================================
FILE CONTENTS:
================================================================================

---
File: .gitignore
---

HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/


---
File: pom.xml
---

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.4.5</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.example.chatbot</groupId>
	<artifactId>LLMSystem</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>LLMSystem</name>
	<description>LLMSystem</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.1</spring-cloud.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.thymeleaf.extras</groupId>
			<artifactId>thymeleaf-extras-springsecurity6</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		
		<!-- Spring Cloud 相关依赖 - 新增 -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-context</artifactId>
		</dependency>
		
		<!-- 处理 PDF 文本 -->
		<dependency>
			<groupId>org.apache.pdfbox</groupId>
			<artifactId>pdfbox</artifactId>
			<version>2.0.24</version>
		</dependency>

		<!-- 处理 DOCX 文本 -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>5.2.3</version>
		</dependency>

		<!-- 1. DJL 核心 API -->
		<dependency>
			<groupId>ai.djl</groupId>
			<artifactId>api</artifactId>
			<version>0.32.0</version>
		</dependency>

		<!-- 2. PyTorch 引擎适配 -->
		<dependency>
			<groupId>ai.djl.pytorch</groupId>
			<artifactId>pytorch-engine</artifactId>
			<version>0.32.0</version>
		</dependency>

		<!-- 3. GPU 本地二进制 (CUDA 12.4) -->
		<dependency>
			<groupId>ai.djl.pytorch</groupId>
			<artifactId>pytorch-native-cu124</artifactId>
			<version>2.5.1</version>
			<classifier>win-x86_64</classifier>
		</dependency>

		<!-- 4. （可选）CPU 本地二进制备选 -->
		<dependency>
			<groupId>ai.djl.pytorch</groupId>
			<artifactId>pytorch-native-cpu</artifactId>
			<version>2.5.1</version>
			<classifier>win-x86_64</classifier>
		</dependency>

		<!-- 5. NLP 支持：Hugging Face Tokenizers -->
		<dependency>
			<groupId>ai.djl.huggingface</groupId>
			<artifactId>tokenizers</artifactId>
			<version>0.32.0</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-webflux</artifactId>
		</dependency>
		<!-- Spring Boot Actuator - 用于配置刷新等接口 -->
		<dependency>
		    <groupId>org.springframework.boot</groupId>
		    <artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>

---
File: src\main\java\com\example\chatbot\LlmSystemApplication.java
---

package com.example.chatbot;

import com.example.chatbot.service.EmbeddingService;
import com.example.chatbot.service.KnowledgeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

import java.util.Map;
import java.util.stream.Collectors;

@SpringBootApplication
public class LlmSystemApplication {

    public static void main(String[] args) {
        SpringApplication.run(LlmSystemApplication.class, args);
    }

    @Bean
    public CommandLineRunner demoProcess(KnowledgeService ks, EmbeddingService es) {
        return args -> {
            // 演示用：启动时执行一些操作（可省略）
            System.out.println(">> 知识库服务就绪");
        };
    }

    /**
     * 启动时打印所有 @RequestMapping 信息，帮助排查哪些接口被注册了
     */
    @Bean
    public CommandLineRunner printAllMappings(
            @Qualifier("requestMappingHandlerMapping") RequestMappingHandlerMapping mapping) {
        return args -> {
            System.out.println("==== 所有请求映射 ====");
            // 获取 URL 与控制器的映射关系
            Map<?, ?> map = mapping.getHandlerMethods();
            map.forEach((key, value) -> {
                // 打印 URL 路径和对应处理方法信息
                System.out.printf("路径: %s >> 方法: %s%n",
                        formatEndpoint(key),
                        value);
            });
            System.out.println("==== 映射列表完毕 ====");
        };
    }

    private String formatEndpoint(Object key) {
        if (key.toString().contains("specific=")) {
            return key.toString().replaceAll(".*\\{(.*)\\}.*", "$1")
                    .replace("[", "")
                    .replace("]", "")
                    .replace("specific=", "")
                    .lines()
                    .map(String::trim)
                    .collect(Collectors.joining(", "));
        }
        return key.toString();
    }
}

---
File: src\main\java\com\example\chatbot\config\PromptProperties.java
---

package com.example.chatbot.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.stereotype.Component;

/**
 * 聊天机器人提示词配置，可在 application.properties 中编写，
 * 支持通过 Spring Cloud 的 RefreshScope 进行实时刷新。
 */
@Component
@ConfigurationProperties(prefix = "chatbot.prompt")
@RefreshScope
@Data
public class PromptProperties {
    /** 系统级设定（人格、角色、语气等） */
    private String system;

    /** 当知识库为空或不足时的兜底回答 */
    private String fallback;
    
    /** 防止幻觉的额外指令 */
    private String preventHallucination;
    
    /** 知识库引用提示 */
    private String citation;
    
    /** 回答格式指导 */
    private String formatInstruction;
}

---
File: src\main\java\com\example\chatbot\config\SecurityConfig.java
---

package com.example.chatbot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())  // 禁用CSRF保护，方便测试
            .authorizeHttpRequests(auth ->
                            auth.anyRequest().permitAll()
//                auth.requestMatchers("/api/**").permitAll()  // 允许/api/**路径的请求无需认证
//                    .anyRequest().authenticated()
            );
        
        return http.build();
    }
}

---
File: src\main\java\com\example\chatbot\config\WebClientConfig.java
---

package com.example.chatbot.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {

    @Value("${ollama.api.url:http://localhost:11434}")
    private String ollamaUrl;

    @Bean
    public WebClient ollamaClient() {
        return WebClient.builder()
                .baseUrl(ollamaUrl)
                .build();
    }
}


---
File: src\main\java\com\example\chatbot\controller\ChatBotController.java
---

package com.example.chatbot.controller;

import com.example.chatbot.service.ChatService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * AI 聊天接口
 */
@RestController
@RequestMapping("/api/chat")
public class ChatBotController {

    @Autowired
    private ChatService chatService;

    @GetMapping("/ping")
    public String ping() {
        return "pong";
    }

    /**
     * 用户提问接口
     * @param req 包含字段: question(用户问题)
     */
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<AnswerResponse> chat(@RequestBody QuestionRequest req) {
        if (req.getQuestion() == null || req.getQuestion().trim().isEmpty()) {
            return ResponseEntity.badRequest().build();
        }
        
        String answer = chatService.getAnswer(req.getQuestion());
        return ResponseEntity.ok(new AnswerResponse(answer));
    }

    // 请求 DTO
    public static class QuestionRequest {
        private String question;
        
        public String getQuestion() { 
            return question; 
        }
        
        public void setQuestion(String question) { 
            this.question = question; 
        }
    }

    // 响应 DTO
    public static class AnswerResponse {
        private String answer;
        
        public AnswerResponse() {}
        
        public AnswerResponse(String answer) { 
            this.answer = answer; 
        }
        
        public String getAnswer() { 
            return answer; 
        }
        
        public void setAnswer(String answer) {
            this.answer = answer;
        }
    }
}

---
File: src\main\java\com\example\chatbot\controller\ChatController.java
---

package com.example.chatbot.controller;

import com.example.chatbot.model.Chat;
import com.example.chatbot.service.ChatService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 聊天记录 CRUD 接口
 */
@RestController
@RequestMapping("/api/chats")
public class ChatController {

    @Autowired
    private ChatService chatService;

    /** 创建聊天记录 */
    @PostMapping
    public ResponseEntity<Chat> createChat(@RequestBody Chat chat) {
        Chat saved = chatService.createChat(chat);
        return ResponseEntity.ok(saved);
    }

    /** 查询所有聊天记录 */
    @GetMapping
    public ResponseEntity<List<Chat>> getAllChats() {
        return ResponseEntity.ok(chatService.getAllChats());
    }

    /** 根据 ID 查询聊天记录 */
    @GetMapping("/{id}")
    public ResponseEntity<Chat> getChatById(@PathVariable Long id) {
        return chatService.getChatById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /** 更新聊天记录 */
    @PutMapping("/{id}")
    public ResponseEntity<Chat> updateChat(
            @PathVariable Long id,
            @RequestBody Chat chat) {
        return chatService.updateChat(id, chat)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /** 删除聊天记录 */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteChat(@PathVariable Long id) {
        chatService.deleteChat(id);
        return ResponseEntity.noContent().build();
    }
}


---
File: src\main\java\com\example\chatbot\controller\ConfigController.java
---

package com.example.chatbot.controller;

import com.example.chatbot.config.PromptProperties;
import lombok.RequiredArgsConstructor;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * 配置相关的控制器，提供查看当前配置的接口
 */
@RestController
@RequestMapping("/api/config")
@RequiredArgsConstructor
public class ConfigController {

    private final PromptProperties promptProperties;

    /**
     * 获取当前的提示词配置
     */
    @GetMapping("/prompt-settings")
    public Map<String, String> getPromptSettings() {
        Map<String, String> result = new HashMap<>();
        result.put("system", promptProperties.getSystem());
        result.put("fallback", promptProperties.getFallback());
        return result;
    }
}

---
File: src\main\java\com\example\chatbot\controller\KnowledgeController.java
---

package com.example.chatbot.controller;

import com.example.chatbot.model.Document;
import com.example.chatbot.service.KnowledgeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

/**
 * 知识库文件上传接口
 */
@RestController
@RequestMapping("/api/knowledge")
public class KnowledgeController {

    @Autowired
    private KnowledgeService knowledgeService;

    /**
     * 上传知识库文件
     * @param file MultipartFile（支持 txt、pdf、docx…）
     */
    @PostMapping("/upload")
    public ResponseEntity<Document> upload(@RequestParam("file") MultipartFile file) {
        Document doc = knowledgeService.uploadAndProcess(file);
        return ResponseEntity.ok(doc);
    }
    
    /**
     * 获取所有上传的知识库文件
     * @return 文件列表
     */
    @GetMapping("/files")
    public ResponseEntity<List<Document>> getAllFiles() {
        List<Document> files = knowledgeService.getAllDocuments();
        return ResponseEntity.ok(files);
    }
}

---
File: src\main\java\com\example\chatbot\controller\UserController.java
---

package com.example.chatbot.controller;

import com.example.chatbot.model.User;
import com.example.chatbot.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 用户 CRUD 接口
 */
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    /** 创建用户 */
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User saved = userService.createUser(user);
        return ResponseEntity.ok(saved);
    }

    /** 查询所有用户 */
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        return ResponseEntity.ok(userService.getAllUsers());
    }

    /** 根据 ID 查询单个用户 */
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.getUserById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /** 更新用户（需提供完整 User 对象） */
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @RequestBody User user) {
        return userService.updateUser(id, user)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /** 删除用户 */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}


---
File: src\main\java\com\example\chatbot\model\Chat.java
---

package com.example.chatbot.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 聊天记录实体
 */
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "chats")
public class Chat {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id")
    private Long userId;

    @Column(name = "session_id")
    private String sessionId;

    // 用户问题
    @Column(length = 1000, nullable = false)
    private String question;

    // AI回答
    @Column(length = 10000)
    private String answer;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

---
File: src\main\java\com\example\chatbot\model\Document.java
---

package com.example.chatbot.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import java.time.LocalDateTime;

/**
 * 知识库文档元数据
 */
@Entity
@Table(name = "documents")
public class Document {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // 原始文件名
    private String filename;

    // 存储在本地的相对路径（或绝对路径）
    private String filepath;

    // 上传时间
    private LocalDateTime uploadTime;

    public Document() {}

    // ———— getter/setter ————
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getFilename() { return filename; }
    public void setFilename(String filename) { this.filename = filename; }
    public String getFilepath() { return filepath; }
    public void setFilepath(String filepath) { this.filepath = filepath; }
    public LocalDateTime getUploadTime() { return uploadTime; }
    public void setUploadTime(LocalDateTime uploadTime) { this.uploadTime = uploadTime; }
}


---
File: src\main\java\com\example\chatbot\model\Segment.java
---

package com.example.chatbot.model;

import jakarta.persistence.*;
import lombok.Data;

/**
 * 文本片段（Chunk）实体：
 * 代表从知识库文档中切分出的一个小段落，用于检索和嵌入。
 */
@Data
@Entity
@Table(name = "segments")
public class Segment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // 所属 Document 的主键
    private Long documentId;

    // 这个片段的纯文本内容
    @Column(columnDefinition = "TEXT")
    private String content;

    // 预留：后面存 embedding 向量时用（暂时不入库）
    // @Lob
    // private byte[] embedding;

    // 新增：向量存储字段
    @Lob
    @Column(columnDefinition = "LONGBLOB")
    private byte[] vector;

}


---
File: src\main\java\com\example\chatbot\model\User.java
---

package com.example.chatbot.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

/**
 * 用户实体，对应数据库中的 users 表
 */
@Setter
@Getter
@Entity              // 标记这是一个 JPA 实体
@Table(name = "users") // 指定数据库表名为 users
public class User {

    // 主键 id，自增
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // 登录用户名，唯一
    private String username;

    // 登录密码，存储加密后的哈希值
    private String password;

    // ----------- 以下为 getter 和 setter 方法 -----------

    // JPA 需要有无参构造函数
    public User() {}

    // 可选：重写 toString，方便调试时打印
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                '}';
    }
}


---
File: src\main\java\com\example\chatbot\repository\ChatRepository.java
---

package com.example.chatbot.repository;

import com.example.chatbot.model.Chat;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * 聊天记录数据访问接口
 */
@Repository
public interface ChatRepository extends JpaRepository<Chat, Long> {
    // 如有需要，可自定义更多查询方法
}


---
File: src\main\java\com\example\chatbot\repository\DocumentRepository.java
---

package com.example.chatbot.repository;

import com.example.chatbot.model.Document;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * 文档元数据访问接口
 */
@Repository
public interface DocumentRepository extends JpaRepository<Document, Long> {
}


---
File: src\main\java\com\example\chatbot\repository\SegmentRepository.java
---

package com.example.chatbot.repository;

import com.example.chatbot.model.Segment;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 文本片段 数据访问接口
 */
@Repository
public interface SegmentRepository extends JpaRepository<Segment, Long> {
    // 日后可以按 documentId 查询：List<Segment> findByDocumentId(Long documentId);
    /**
     * 根据文档 ID 查询所有分段
     */
    List<Segment> findByDocumentId(Long documentId);
}


---
File: src\main\java\com\example\chatbot\repository\UserRepository.java
---

package com.example.chatbot.repository;

import com.example.chatbot.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * 用户数据访问接口
 */
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // 根据用户名查询用户
    User findByUsername(String username);
}


---
File: src\main\java\com\example\chatbot\service\ChatService.java
---

package com.example.chatbot.service;

// 导入需要的类
import com.example.chatbot.model.Chat;  // 用于存储聊天记录的模型类
import com.example.chatbot.repository.ChatRepository;  // 用于数据库操作的仓库接口
import com.example.chatbot.service.IntentRecognitionService.Intent;  // 意图类型的枚举
import org.springframework.beans.factory.annotation.Autowired;  // 自动注入依赖
import org.springframework.stereotype.Service;  // 标记这是一个服务类

import java.time.LocalDateTime;  // 日期时间类
import java.time.LocalTime;  // 时间类
import java.util.*;  // 集合框架
import java.util.logging.Logger;  // 日志记录

// @Service 注解表明这是一个Spring服务组件，Spring会自动管理它的生命周期
@Service
public class ChatService {

    // 创建日志记录器
    private static final Logger logger = Logger.getLogger(ChatService.class.getName());

    // 创建一个用于存储会话状态的内存缓存
    // 外层Map的键是会话ID，值是内部Map
    // 内部Map存储各种会话相关的状态信息
    private final Map<String, Map<String, Object>> sessionStates = new HashMap<>();

    // @Autowired 注解让Spring自动注入这些依赖
    // ChatRepository用于操作聊天记录数据库
    @Autowired
    private ChatRepository chatRepository;

    // LLMService用于与大型语言模型交互
    @Autowired
    private LLMService llmService;

    // EmbeddingService用于生成和查询文本的向量嵌入
    @Autowired
    private EmbeddingService embeddingService;

    // IntentRecognitionService用于识别用户问题的意图
    @Autowired
    private IntentRecognitionService intentRecognitionService;

    /**
     * 创建聊天记录
     * @param chat 聊天对象
     * @return 保存后的聊天对象（包含ID等）
     */
    public Chat createChat(Chat chat) {
        // 如果未设置创建时间，则设置为当前时间
        if (chat.getCreatedAt() == null) {
            chat.setCreatedAt(LocalDateTime.now());
        }
        // 保存到数据库并返回
        return chatRepository.save(chat);
    }

    /**
     * 获取所有聊天记录
     * @return 所有聊天记录的列表
     */
    public List<Chat> getAllChats() {
        // 直接调用仓库方法查询所有记录
        return chatRepository.findAll();
    }

    /**
     * 根据ID获取特定的聊天记录
     * @param id 聊天记录ID
     * @return 包含聊天记录的Optional对象（可能为空）
     */
    public Optional<Chat> getChatById(Long id) {
        // 调用仓库方法根据ID查询
        return chatRepository.findById(id);
    }

    /**
     * 更新聊天记录
     * @param id 要更新的聊天记录ID
     * @param chat 包含更新内容的聊天对象
     * @return 更新后的聊天对象（如果存在）
     */
    public Optional<Chat> updateChat(Long id, Chat chat) {
        // 先查找是否存在该ID的记录
        return chatRepository.findById(id)
                .map(existingChat -> {
                    // 如果存在，则更新可修改字段

                    // 仅当新值不为null时才更新userId
                    if (chat.getUserId() != null) {
                        existingChat.setUserId(chat.getUserId());
                    }
                    // 仅当新值不为null时才更新问题
                    if (chat.getQuestion() != null) {
                        existingChat.setQuestion(chat.getQuestion());
                    }
                    // 仅当新值不为null时才更新回答
                    if (chat.getAnswer() != null) {
                        existingChat.setAnswer(chat.getAnswer());
                    }
                    // 设置更新时间为当前时间
                    existingChat.setUpdatedAt(LocalDateTime.now());

                    // 保存并返回更新后的实体
                    return chatRepository.save(existingChat);
                });
    }

    /**
     * 删除聊天记录
     * @param id 要删除的聊天记录ID
     */
    public void deleteChat(Long id) {
        // 调用仓库方法删除指定ID的记录
        chatRepository.deleteById(id);
    }

    /**
     * 获取问题的回答
     * @param question 用户的问题
     * @param sessionId 会话ID，用于追踪上下文，如果为null则创建新会话
     * @return 生成的回答
     */
    public String getAnswer(String question, String sessionId) {
        // 如果没有会话ID，创建一个新的
        if (sessionId == null || sessionId.isEmpty()) {
            // 生成一个随机UUID作为会话ID
            sessionId = UUID.randomUUID().toString();
            // 初始化新会话
            initializeSession(sessionId);
        }

        try {
            // 获取或初始化会话状态
            Map<String, Object> sessionState = getOrCreateSessionState(sessionId);

            // 更新会话状态 - 记录本次问题
            // 从会话状态中获取历史记录，如果不存在则创建新的列表
            List<String> history = (List<String>) sessionState.getOrDefault("history", new ArrayList<String>());
            // 添加当前问题到历史记录
            history.add("Q: " + question);
            // 更新会话状态中的历史记录
            sessionState.put("history", history);

            // 更新会话状态 - 记录问题时间
            sessionState.put("lastActivity", LocalDateTime.now());

            // 1. 识别用户问题的意图
            Intent intent = intentRecognitionService.recognizeIntentWithLLM(question);
            // 记录识别到的意图
            logger.info("用户问题: '" + question + "' 识别到的意图: " + intent);

            // 记录意图到会话状态
            sessionState.put("lastIntent", intent);

            // 2. 根据不同意图类型处理
            String answer;
            // 使用switch语句根据不同的意图类型调用不同的处理方法
            switch (intent) {
                case CHIT_CHAT:
                    // 处理闲聊类型的问题
                    answer = handleChitChat(question, sessionState);
                    break;
                case SYSTEM:
                    // 处理系统相关的问题
                    answer = handleSystemQuestion(question, sessionState);
                    break;
                case SENSITIVE:
                    // 处理敏感内容
                    answer = handleSensitiveContent(question, sessionState);
                    break;
                case UNCLEAR:
                    // 处理不明确的问题
                    answer = handleUnclearQuestion(question, sessionState);
                    break;
                case OUT_OF_SCOPE:
                    // 处理超出范围的问题
                    answer = handleOutOfScopeQuestion(question, sessionState);
                    break;
                case KNOWLEDGE:
                default:
                    // 对于知识型问题，使用知识库检索
                    answer = handleKnowledgeQuery(question, sessionState);
                    break;
            }

            // 更新会话状态 - 记录本次回答
            history.add("A: " + answer);

            // 保存聊天记录到数据库
            saveChat(question, answer, sessionId);

            // 返回生成的回答
            return answer;
        } catch (Exception e) {
            // 记录错误日志
            logger.severe("处理问题时发生错误: " + e.getMessage());
            // 打印完整的错误堆栈
            e.printStackTrace();
            // 返回友好的错误消息
            return "抱歉，处理您的问题时出现了错误。";
        }
    }

    /**
     * 为兼容现有接口，不带sessionId的重载方法
     * @param question 用户的问题
     * @return 生成的回答
     */
    public String getAnswer(String question) {
        // 调用带sessionId参数的方法，但传入null
        return getAnswer(question, null);
    }

    /**
     * 获取或创建会话状态
     * @param sessionId 会话ID
     * @return 对应会话ID的状态Map
     */
    private Map<String, Object> getOrCreateSessionState(String sessionId) {
        // 检查会话状态Map中是否已存在该会话ID
        if (!sessionStates.containsKey(sessionId)) {
            // 如果不存在，初始化一个新会话
            initializeSession(sessionId);
        }
        // 返回该会话ID对应的状态Map
        return sessionStates.get(sessionId);
    }

    /**
     * 初始化新会话
     * @param sessionId 会话ID
     */
    private void initializeSession(String sessionId) {
        // 创建一个新的Map来存储会话状态
        Map<String, Object> state = new HashMap<>();
        // 记录会话创建时间
        state.put("createdAt", LocalDateTime.now());
        // 记录最后活动时间
        state.put("lastActivity", LocalDateTime.now());
        // 初始化空的历史记录列表
        state.put("history", new ArrayList<String>());
        // 初始化问候计数器
        state.put("greetingCount", 0);
        // 初始化投诉计数器
        state.put("complaintCount", 0);
        // 将新创建的状态Map添加到会话状态Map中
        sessionStates.put(sessionId, state);
    }

    /**
     * 保存聊天记录到数据库
     * @param question 用户问题
     * @param answer 系统回答
     * @param sessionId 会话ID
     */
    private void saveChat(String question, String answer, String sessionId) {
        // 创建一个新的Chat对象
        Chat chat = new Chat();
        // 设置问题
        chat.setQuestion(question);
        // 设置回答
        chat.setAnswer(answer);
        // 设置会话ID
        chat.setSessionId(sessionId);
        // 设置创建时间
        chat.setCreatedAt(LocalDateTime.now());
        // 保存到数据库
        chatRepository.save(chat);
    }

    /**
     * 处理问候类型的问题
     * @param question 用户问题
     * @param sessionState 会话状态
     * @return 生成的回答
     */
    private String handleGreeting(String question, Map<String, Object> sessionState) {
        // 增加问候计数
        int greetingCount = (int) sessionState.getOrDefault("greetingCount", 0);
        // 更新计数值到会话状态
        sessionState.put("greetingCount", greetingCount + 1);

        // 获取当前时段
        LocalTime now = LocalTime.now();
        String timeOfDay;

        // 根据当前时间确定是早上、下午还是晚上
        if (now.isBefore(LocalTime.of(12, 0))) {
            timeOfDay = "早上";
        } else if (now.isBefore(LocalTime.of(18, 0))) {
            timeOfDay = "下午";
        } else {
            timeOfDay = "晚上";
        }

        // 根据问候次数和时段生成不同的问候语
        if (greetingCount <= 1) {
            // 第一次问候，使用标准问候语
            String[] greetings = {
                    timeOfDay + "好！有什么我可以帮助你的吗？",
                    timeOfDay + "好！很高兴为您服务。",
                    "嗨，" + timeOfDay + "好！请问有什么我可以协助您的？"
            };
            // 随机选择一个问候语返回
            return greetings[(int) (Math.random() * greetings.length)];
        } else {
            // 重复问候，给出不同回应
            String[] repeatedGreetings = {
                    "我们已经打过招呼了。有什么可以帮您的吗？",
                    "您好！请问有什么具体问题需要解答？",
                    "我在这里。请问有什么我能做的？"
            };
            // 随机选择一个重复问候回应返回
            return repeatedGreetings[(int) (Math.random() * repeatedGreetings.length)];
        }
    }

    /**
     * 处理告别类型的问题
     * @param question 用户问题
     * @param sessionState 会话状态
     * @return 生成的回答
     */
    private String handleFarewell(String question, Map<String, Object> sessionState) {
        // 标记会话可能结束
        sessionState.put("farewellSent", true);

        // 告别语数组
        String[] farewells = {
                "再见！如果有其他问题，随时回来咨询。",
                "下次见！祝您一切顺利。",
                "再会！有需要随时找我。"
        };
        // 随机选择一个告别语返回
        return farewells[(int) (Math.random() * farewells.length)];
    }

    /**
     * 处理感谢类型的问题
     * @param question 用户问题
     * @param sessionState 会话状态
     * @return 生成的回答
     */
    private String handleThanks(String question, Map<String, Object> sessionState) {
        // 分析之前有没有帮助过用户
        List<String> history = (List<String>) sessionState.getOrDefault("history", new ArrayList<String>());
        // 判断是否有实质性对话（至少有3轮对话）
        boolean hasProvided = history.size() > 2;

        if (hasProvided) {
            // 如果有实质性帮助，回复更热情
            String[] responses = {
                    "不客气！很高兴能帮到您。",
                    "您太客气了，这是我的荣幸。",
                    "不用谢！如果还有其他问题，随时告诉我。"
            };
            // 随机选择一个回应返回
            return responses[(int) (Math.random() * responses.length)];
        } else {
            // 用户可能没有得到实质性帮助就感谢
            String[] simpleResponses = {
                    "不用谢！有什么具体问题我可以帮您解答吗？",
                    "很高兴能帮到您。您有什么特定问题需要咨询吗？",
                    "不客气！请问您需要什么帮助？"
            };
            // 随机选择一个简单回应返回
            return simpleResponses[(int) (Math.random() * simpleResponses.length)];
        }
    }

    /**
     * 处理帮助请求类型的问题
     * @param question 用户问题
     * @param sessionState 会话状态
     * @return 生成的回答
     */
    private String handleHelp(String question, Map<String, Object> sessionState) {
        // 返回系统功能介绍
        return "我是一个AI助手，可以回答您的问题、提供信息和帮助解决问题。您可以：\n\n" +
                "1. 询问任何专业知识问题\n" +
                "2. 寻求技术支持或使用指导\n" +
                "3. 提供反馈或建议\n" +
                "4. 提交投诉或问题报告\n\n" +
                "请告诉我您具体需要什么帮助，我会尽力提供准确的回答。";
    }

    /**
     * 处理澄清请求类型的问题
     * @param question 用户问题
     * @param sessionState 会话状态
     * @return 生成的回答
     */
    private String handleClarification(String question, Map<String, Object> sessionState) {
        // 尝试查找上一次的回答以提供澄清
        List<String> history = (List<String>) sessionState.getOrDefault("history", new ArrayList<String>());
        String lastAnswer = "";
        
        // 从历史记录末尾向前查找，找到最近的一条系统回答
        for (int i = history.size() - 1; i >= 0; i--) {
            String entry = history.get(i);
            if (entry.startsWith("A: ")) {
                // 去掉 "A: " 前缀，获取实际回答内容
                lastAnswer = entry.substring(3);
                break;
            }
        }

        if (!lastAnswer.isEmpty()) {
            // 用上一次的回答作为上下文，请求LLM提供澄清
            // 构建提示词，引导LLM提供基于上一次回答的澄清
            String clarificationPrompt = String.format(
                    "用户对我之前的回答请求澄清。\n" +
                            "我的上一次回答是: %s\n" +
                            "用户的请求是: %s\n" +
                            "请基于我上一次的回答，提供更清晰、更详细的解释。",
                    lastAnswer, question
            );
            // 调用LLM生成澄清回答
            return llmService.generateResponse(clarificationPrompt);
        } else {
            // 没有前文上下文，请用户提供更多细节
            return "抱歉，我可能无法理解您的问题。请提供更多细节，或者用不同的方式表述您的问题，我会尽力帮助您。";
        }
    }

    /**
     * 处理投诉类型的问题
     * @param question 用户问题
     * @param sessionState 会话状态
     * @return 生成的回答
     */
    private String handleComplaint(String question, Map<String, Object> sessionState) {
        // 跟踪投诉次数
        int complaintCount = (int) sessionState.getOrDefault("complaintCount", 0);
        // 更新投诉计数到会话状态
        sessionState.put("complaintCount", complaintCount + 1);

        if (complaintCount >= 2) {
            // 多次投诉，提供转人工选项
            return "非常抱歉您遇到了持续的问题。我们可以为您转接人工客服以获取进一步帮助。请问您希望转接人工客服吗？";
        } else {
            return "非常抱歉给您带来不便。我们非常重视您的反馈，会努力改进我们的服务。请详细描述您遇到的问题，以便我们能更好地帮助您解决。如果需要，我也可以为您转接人工客服。";
        }
    }

    /**
     * 处理反馈类型的问题
     */
    private String handleFeedback(String question, Map<String, Object> sessionState) {
        // 区分积极反馈和消极反馈
        if (question.contains("好") || question.contains("赞") || question.contains("优秀") ||
                question.contains("good") || question.contains("great") || question.contains("excellent")) {
            return "非常感谢您的积极评价！我们会继续努力提供优质服务。如果您有更多建议，也欢迎随时提出。";
        } else {
            return "感谢您的反馈！您的意见对我们非常重要，我们会认真考虑您的建议，不断改进我们的服务。如果您有更具体的建议，也请告诉我们。";
        }
    }

    /**
     * 处理信息查询类型的问题
     */
    private String handleInformationQuery(String question, Map<String, Object> sessionState) {
        // 1. 查询相关知识片段
        List<String> relevantSegments = embeddingService.findRelevantSegments(question, 3);

        // 2. 获取历史对话作为上下文
        List<String> history = (List<String>) sessionState.getOrDefault("history", new ArrayList<String>());
        String conversationContext = "";

        // 只取最近的3轮对话作为上下文
        int startIndex = Math.max(0, history.size() - 6); // 3轮问答共6条记录
        if (startIndex < history.size()) {
            conversationContext = String.join("\n", history.subList(startIndex, history.size() - 1));  // 不包括当前问题
            if (!conversationContext.isEmpty()) {
                conversationContext = "对话历史：\n" + conversationContext + "\n\n";
            }
        }

        // 3. 调用 LLM 服务生成回答，加入对话历史作为上下文
        return llmService.generateAnswerWithContext(question, relevantSegments, conversationContext);
    }

    /**
     * 处理闲聊类型的问题（问候、感谢、告别等）
     */
    private String handleChitChat(String question, Map<String, Object> sessionState) {
        String lowercaseQuestion = question.toLowerCase();
        
        // 问候处理
        if (lowercaseQuestion.contains("你好") || lowercaseQuestion.contains("早上") || 
                lowercaseQuestion.contains("下午") || lowercaseQuestion.contains("晚上") || 
                lowercaseQuestion.contains("嗨") || lowercaseQuestion.contains("hi") || 
                lowercaseQuestion.contains("hello")) {
            return handleGreeting(question, sessionState);
        }
        
        // 告别处理
        if (lowercaseQuestion.contains("再见") || lowercaseQuestion.contains("拜拜") || 
                lowercaseQuestion.contains("bye") || lowercaseQuestion.contains("goodbye")) {
            return handleFarewell(question, sessionState);
        }
        
        // 感谢处理
        if (lowercaseQuestion.contains("谢谢") || lowercaseQuestion.contains("感谢") || 
                lowercaseQuestion.contains("thanks") || lowercaseQuestion.contains("thank")) {
            return handleThanks(question, sessionState);
        }
        
        // 其他社交对话
        String[] chitChatResponses = {
            "我很好，谢谢关心！您有什么我可以帮助的吗？",
            "很高兴与您交流！有什么具体问题吗？",
            "我随时准备为您提供帮助！"
        };
        return chitChatResponses[(int)(Math.random() * chitChatResponses.length)];
    }

    /**
     * 处理系统相关问题（关于机器人自身或功能）
     */
    private String handleSystemQuestion(String question, Map<String, Object> sessionState) {
        String lowercaseQuestion = question.toLowerCase();
        
        // 关于机器人身份的问题
        if (lowercaseQuestion.contains("你是谁") || lowercaseQuestion.contains("介绍自己") || 
                lowercaseQuestion.contains("你叫什么") || lowercaseQuestion.contains("你的名字")) {
            return "我是ZZY，一个AI助手，旨在提供信息和回答问题。我基于人工智能技术开发，能够理解并回答各种问题，访问知识库获取信息，并尽力为您提供有用的回答。";
        }
        
        // 关于机器人功能的问题
        if (lowercaseQuestion.contains("你能做什么") || lowercaseQuestion.contains("你的功能") || 
                lowercaseQuestion.contains("help") || lowercaseQuestion.contains("帮助")) {
            return handleHelp(question, sessionState);
        }
        
        // 其他系统相关问题
        return "我是ZZY，一个AI助手，可以回答您的问题、提供信息和帮助解决问题。有什么我可以帮您的吗？";
    }

    /**
     * 处理敏感内容
     */
    private String handleSensitiveContent(String question, Map<String, Object> sessionState) {
        String[] responses = {
            "抱歉，我无法讨论这类敏感话题。有其他我可以帮助您的问题吗？",
            "这个话题超出了我的服务范围。您可以问我一些其他问题。",
            "作为AI助手，我被设计为不讨论敏感或有争议的话题。有其他我可以帮助您的事情吗？"
        };
        return responses[(int)(Math.random() * responses.length)];
    }

    /**
     * 处理不明确的问题
     */
    private String handleUnclearQuestion(String question, Map<String, Object> sessionState) {
        String[] responses = {
            "抱歉，我不太理解您的问题。能否换一种方式表述，或提供更多细节？",
            "您的问题有点模糊，能否详细说明一下您想了解什么？",
            "我没能完全理解您的意思。请问您能更具体地描述您的问题吗？"
        };
        return responses[(int)(Math.random() * responses.length)];
    }

    /**
     * 处理超出范围的问题
     */
    private String handleOutOfScopeQuestion(String question, Map<String, Object> sessionState) {
        String[] responses = {
            "抱歉，这个问题超出了我的能力范围。我无法提供实时数据或执行具体操作。",
            "作为AI助手，我无法执行这类操作。有其他我可以帮助您的问题吗？",
            "这超出了我的功能范围。我主要擅长回答问题和提供信息，而不能执行具体任务。"
        };
        return responses[(int)(Math.random() * responses.length)];
    }

    /**
     * 处理知识型查询
     */
    private String handleKnowledgeQuery(String question, Map<String, Object> sessionState) {
        // 1. 查询相关知识片段
        List<String> relevantSegments = embeddingService.findRelevantSegments(question, 3);

        // 2. 获取历史对话作为上下文
        List<String> history = (List<String>) sessionState.getOrDefault("history", new ArrayList<String>());
        String conversationContext = "";

        // 只取最近的3轮对话作为上下文
        int startIndex = Math.max(0, history.size() - 6); // 3轮问答共6条记录
        if (startIndex < history.size()) {
            conversationContext = String.join("\n", history.subList(startIndex, history.size() - 1));  // 不包括当前问题
            if (!conversationContext.isEmpty()) {
                conversationContext = "对话历史：\n" + conversationContext + "\n\n";
            }
        }

        // 3. 如果没有找到相关知识片段，返回无法回答的消息
        if (relevantSegments.isEmpty()) {
            return "抱歉，我的知识库中没有与您问题相关的信息。您可以尝试换一种方式提问，或询问其他问题。";
        }

        // 4. 调用 LLM 服务生成回答，加入对话历史作为上下文
        return llmService.generateAnswerWithContext(question, relevantSegments, conversationContext);
    }
}

---
File: src\main\java\com\example\chatbot\service\EmbeddingService.java
---

package com.example.chatbot.service;

import ai.djl.Device;
import ai.djl.MalformedModelException;
import ai.djl.inference.Predictor;
import ai.djl.repository.zoo.Criteria;
import ai.djl.repository.zoo.ModelNotFoundException;
import ai.djl.repository.zoo.ModelZoo;
import ai.djl.repository.zoo.ZooModel;
import ai.djl.translate.TranslateException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.example.chatbot.repository.SegmentRepository;
import com.example.chatbot.model.Segment;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import java.io.IOException;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * 嵌入向量服务：支持多种嵌入模式
 * 1. Ollama API（默认）
 * 2. 本地DJL实现
 * 3. 远程API（预留扩展）
 */
@Service
public class EmbeddingService {
    private static final Logger logger = Logger.getLogger(EmbeddingService.class.getName());
    
    private final WebClient client;
    // 内存索引：segmentId -> vector
    private final Map<Long, float[]> vectorIndex = new ConcurrentHashMap<>();

    @Value("${embedding.mode:local}")
    private String embeddingMode;

    @Value("${ollama.embedModel:nomic-embed-text}")
    private String embedModel;
    
    @Autowired
    private SegmentRepository segmentRepository;
    
    // DJL相关字段
    private ZooModel<String, float[]> model;
    private Predictor<String, float[]> predictor;
    private boolean djlModelLoaded = false;

    public EmbeddingService(WebClient ollamaClient) {
        this.client = ollamaClient;
    }
    
    @PostConstruct
    public void initialize() {
        // 加载所有已有段落的向量到内存索引
        List<Segment> allSegments = segmentRepository.findAll();
        logger.info("正在加载 " + allSegments.size() + " 个片段的向量到内存...");
        
        int vectorsLoaded = 0;
        for (Segment segment : allSegments) {
            if (segment.getVector() != null) {
                float[] vector = deserializeVector(segment.getVector());
                vectorIndex.put(segment.getId(), vector);
                vectorsLoaded++;
            }
        }
        
        logger.info("成功加载 " + vectorsLoaded + " 个向量到内存索引");
        
        // 如果配置了DJL模式，尝试加载模型
        if ("djl".equalsIgnoreCase(embeddingMode)) {
            loadDjlModel();
        }
    }
    
    @PreDestroy
    public void cleanup() {
        // 释放DJL资源
        if (predictor != null) {
            predictor.close();
        }
        if (model != null) {
            model.close();
        }
    }
    
    /**
     * 加载DJL模型
     */
    private void loadDjlModel() {
        try {
            logger.info("正在加载DJL嵌入模型...");
            
            // 创建模型加载条件
            Criteria<String, float[]> criteria = Criteria.builder()
                    .setTypes(String.class, float[].class)
                    .optModelName("nomic-embed-text")  // 可配置为其他模型
                    .optEngine("PyTorch")
                    .optDevice(Device.cpu())  // 或 Device.gpu()
                    .build();
            
            // 加载模型
            model = ModelZoo.loadModel(criteria);
            predictor = model.newPredictor();
            djlModelLoaded = true;
            
            logger.info("DJL嵌入模型加载成功");
        } catch (ModelNotFoundException | MalformedModelException | IOException e) {
            logger.severe("DJL模型加载失败: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * 核心对外方法：返回一段文本的 embedding 向量
     */
    public float[] embedText(String text) {
        if (text == null || text.trim().isEmpty()) {
            logger.warning("尝试对空文本进行嵌入，返回零向量");
            return new float[512]; // 返回零向量
        }
        
        try {
            switch (embeddingMode.toLowerCase()) {
                case "ollama":
                    return embedViaOllama(text);
                case "djl":
                    return embedViaDJL(text);
                case "remote":
                    return embedViaRemoteApi(text);
                default:
                    logger.warning("未知的嵌入模式: " + embeddingMode + "，使用Ollama作为后备");
                    return embedViaOllama(text);
            }
        } catch (Exception e) {
            logger.severe("嵌入向量生成失败: " + e.getMessage());
            e.printStackTrace();
            // 出错时返回空向量，但在生产环境可能需要更好的错误处理
            return new float[512];
        }
    }

    /**
     * 使用DJL本地生成嵌入向量
     */
    private float[] embedViaDJL(String text) {
        try {
            if (!djlModelLoaded) {
                loadDjlModel();
                if (!djlModelLoaded) {
                    logger.warning("DJL模型未加载，回退到Ollama API");
                    return embedViaOllama(text);
                }
            }
            
            logger.info("通过DJL生成嵌入向量，文本长度: " + text.length());
            float[] embedding = predictor.predict(text);
            logger.info("DJL嵌入向量生成成功，维度: " + embedding.length);
            return embedding;
        } catch (TranslateException e) {
            logger.severe("DJL嵌入生成失败: " + e.getMessage());
            logger.info("尝试回退到Ollama API");
            return embedViaOllama(text);
        }
    }

    /**
     * 用 Ollama REST API 获取 embedding
     */
    @SuppressWarnings("unchecked")
    private float[] embedViaOllama(String text) {
        try {
            logger.info("调用 Ollama Embedding API: model=" + embedModel + ", 文本长度=" + text.length());


            Map<String, Object> req = Map.of(
                    "model", embedModel,
                    "prompt", text
            );

            // 调用 /api/embeddings 端点
            Map<String, Object> resp = client.post()
                    .uri("/api/embeddings")
                    .bodyValue(req)
                    .retrieve()
                    .bodyToMono(Map.class)
                    .timeout(Duration.ofSeconds(30))
                    .block();

            logger.info("收到响应: " + (resp != null ? String.join(", ", resp.keySet()) : "null"));

            // 解析返回 JSON - Ollama API 直接返回 {"embedding": [...]} 而不是嵌套在 data 中
            if (resp == null || !resp.containsKey("embedding")) {
                throw new RuntimeException("Ollama Embeddings API 未返回 embedding 字段");
            }

            // 直接获取 embedding 数组
            List<Number> emb = (List<Number>) resp.get("embedding");
            float[] vector = new float[emb.size()];
            for (int i = 0; i < emb.size(); i++) {
                vector[i] = emb.get(i).floatValue();
            }

            logger.info("成功获取嵌入向量，维度: " + vector.length);
            return vector;
        } catch (Exception e) {
            logger.severe("Ollama嵌入向量调用失败: " + e.getMessage());
            e.printStackTrace();
            // 出错时返回空向量
            return new float[512];
        }
    }
    
    /**
     * 远程 Embedding API 实现
     */
    private float[] embedViaRemoteApi(String text) {
        // 这里可以实现第三方API如OpenAI、DeepSeek等
        logger.warning("远程API嵌入尚未实现，返回零向量");
        return new float[512];
    }

    /**
     * 将指定文本片段索引到内存 map 中并持久化到数据库
     */
    public void indexSegment(Long segmentId, String content) {
        try {
            float[] vector = embedText(content);
            
            // 保存到内存索引
            vectorIndex.put(segmentId, vector);
            
            // 持久化到数据库
            Segment segment = segmentRepository.findById(segmentId)
                    .orElseThrow(() -> new RuntimeException("找不到ID为 " + segmentId + " 的片段"));
            
            segment.setVector(serializeVector(vector));
            segmentRepository.save(segment);
            
            logger.info("成功索引片段 " + segmentId + "，向量维度: " + vector.length);
        } catch (Exception e) {
            logger.severe("索引片段 " + segmentId + " 失败: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * 获取已索引的向量
     */
    public float[] getVector(Long segmentId) {
        return vectorIndex.get(segmentId);
    }

    /**
     * 余弦相似度计算
     */
    public float cosineSimilarity(float[] a, float[] b) {
        if (a == null || b == null || a.length == 0 || b.length == 0 || a.length != b.length) {
            return 0.0f;
        }
        
        double dot = 0, normA = 0, normB = 0;
        for (int i = 0; i < a.length; i++) {
            dot   += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }
        return (float) (dot / (Math.sqrt(normA) * Math.sqrt(normB) + 1e-10));
    }

    /**
     * 给定一个查询向量，返回内存中与之最相似的 Top-K 段 ID 列表
     */
    public List<Long> searchTopK(float[] queryVector, int k) {
        if (queryVector == null || vectorIndex.isEmpty()) {
            return Collections.emptyList();
        }
        
        return vectorIndex.entrySet().stream()
                .map(e -> Map.entry(e.getKey(), cosineSimilarity(queryVector, e.getValue())))
                .sorted((e1, e2) -> Float.compare(e2.getValue(), e1.getValue()))
                .limit(k)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }

    /**
     * 带有相似度阈值的检索方法
     */
    public List<Long> searchTopKWithThreshold(float[] queryVector, int k, float minSimilarity) {
        if (queryVector == null || vectorIndex.isEmpty()) {
            return Collections.emptyList();
        }
        
        return vectorIndex.entrySet().stream()
                .map(e -> Map.entry(e.getKey(), cosineSimilarity(queryVector, e.getValue())))
                .filter(e -> e.getValue() >= minSimilarity) // 添加相似度阈值过滤
                .sorted((e1, e2) -> Float.compare(e2.getValue(), e1.getValue()))
                .limit(k)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }

    /**
     * 返回带得分的检索结果
     */
    public List<Map.Entry<Long, Float>> searchTopKWithScores(float[] queryVector, int k) {
        if (queryVector == null || vectorIndex.isEmpty()) {
            return Collections.emptyList();
        }
        
        return vectorIndex.entrySet().stream()
                .map(e -> Map.entry(e.getKey(), cosineSimilarity(queryVector, e.getValue())))
                .sorted((e1, e2) -> Float.compare(e2.getValue(), e1.getValue()))
                .limit(k)
                .collect(Collectors.toList());
    }

    /**
     * 根据用户问题查找相关的知识片段
     * @param question 用户问题
     * @param limit 返回的最大片段数量
     * @return 相关知识片段列表
     */
    public List<String> findRelevantSegments(String question, int limit) {
        try {
            // 基于相似度检索流程：
            // 1. 生成问题的向量表示
            float[] questionVector = embedText(question);
            
            // 2. 找出最相似的片段ID（相似度阈值为0.7）
            List<Long> topSegmentIds = searchTopKWithThreshold(questionVector, limit, 0.7f);
            
            if (topSegmentIds.isEmpty()) {
                logger.info("没有找到相关的知识片段");
                return Collections.emptyList();
            }
            
            // 3. 查询这些片段的内容
            List<Segment> segments = segmentRepository.findAllById(topSegmentIds);
            
            // 4. 提取内容并返回
            return segments.stream()
                    .map(Segment::getContent)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            logger.severe("查询相关片段时出错: " + e.getMessage());
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
    
    /**
     * 将向量序列化为数据库可存储的格式
     */
    private byte[] serializeVector(float[] vector) {
        byte[] bytes = new byte[vector.length * 4];
        for (int i = 0; i < vector.length; i++) {
            int intBits = Float.floatToIntBits(vector[i]);
            bytes[i * 4] = (byte) (intBits >> 24);
            bytes[i * 4 + 1] = (byte) (intBits >> 16);
            bytes[i * 4 + 2] = (byte) (intBits >> 8);
            bytes[i * 4 + 3] = (byte) (intBits);
        }
        return bytes;
    }
    
    /**
     * 从数据库存储格式反序列化向量
     */
    private float[] deserializeVector(byte[] bytes) {
        if (bytes == null) return null;
        
        int vectorSize = bytes.length / 4;
        float[] vector = new float[vectorSize];
        
        for (int i = 0; i < vectorSize; i++) {
            int intBits = ((bytes[i * 4] & 0xFF) << 24) | //与0xFF进行与计算会让byte先转换成int，计算后由于0xFF高位总是0，所以能去除高位符号，让byte转换成无符号int
                         ((bytes[i * 4 + 1] & 0xFF) << 16) | 
                         ((bytes[i * 4 + 2] & 0xFF) << 8) | 
                         (bytes[i * 4 + 3] & 0xFF);
            vector[i] = Float.intBitsToFloat(intBits);
        }
        return vector;
    }
    
    /**
     * 重新索引所有片段（可用于模型切换后刷新向量）
     */
    public void reindexAllSegments() {
        List<Segment> allSegments = segmentRepository.findAll();
        logger.info("开始重新索引 " + allSegments.size() + " 个片段...");
        
        int count = 0;
        for (Segment segment : allSegments) {
            indexSegment(segment.getId(), segment.getContent());
            count++;
            if (count % 100 == 0) {
                logger.info("已重新索引 " + count + " 个片段");
            }
        }
        
        logger.info("完成全部 " + count + " 个片段的重新索引");
    }
}

---
File: src\main\java\com\example\chatbot\service\IntentRecognitionService.java
---

package com.example.chatbot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.logging.Logger;

/**
 * 意图识别服务：识别用户问题的意图类型
 */
@Service
public class IntentRecognitionService {
    private static final Logger logger = Logger.getLogger(IntentRecognitionService.class.getName());

    /**
     * 意图类型枚举
     */
    public enum Intent {
        // 知识型问题 - 需要查询知识库
        KNOWLEDGE,

        // 闲聊型对话 - 如问候、感谢、告别等社交性质的交流
        CHIT_CHAT,

        // 系统功能 - 关于机器人自身或功能的问题
        SYSTEM,

        // 敏感内容 - 不适合回答的敏感话题
        SENSITIVE,

        // 不明确问题 - 问题模糊或难以理解
        UNCLEAR,

        // 超出范围 - 超出机器人能力范围的问题
        OUT_OF_SCOPE
    }

    @Autowired
    private LLMService llmService;

    /**
     * 使用LLM识别问题意图
     * @param question 用户问题
     * @return 识别出的意图
     */
    public Intent recognizeIntentWithLLM(String question) {
        // 构建提示词，让LLM进行意图分类
        String prompt = buildIntentPrompt(question);

        // 调用LLM服务进行分类
        String response = llmService.generateResponse(prompt);
        logger.info("LLM原始响应: " + response);

        // 从LLM响应中解析意图
        Intent intent = parseIntentFromResponse(response);
        logger.info("从LLM响应中提取到意图: " + intent);

        return intent;
    }

    /**
     * 构建用于意图识别的提示词
     */
    private String buildIntentPrompt(String question) {
        return "你是一个意图分类器。请分析用户问题，并将其归类为以下意图之一：\n" +
                "KNOWLEDGE：需要专业知识或查询知识库回答的问题，如'什么是Java?'、'公司的退货政策是什么?'\n" +
                "CHIT_CHAT：社交性质的问题，如问候('你好'、'早上好')、告别('再见'、'拜拜')、感谢('谢谢'、'谢谢你的帮助')\n" +
                "SYSTEM：关于你自己或系统功能的问题，如'你是谁?'、'你能做什么?'、'介绍一下自己'\n" +
                "SENSITIVE：包含政治、宗教、歧视、成人内容等敏感话题\n" +
                "UNCLEAR：问题模糊、不完整或难以理解\n" +
                "OUT_OF_SCOPE：超出你能力范围的问题，如需要实时数据、执行操作等\n\n" +
                "用户问题：\"" + question + "\"\n\n" +
                "仅回复对应的大写意图类别，不要包含其他任何文字。";
    }

    /**
     * 从LLM响应中解析出意图
     */
    private Intent parseIntentFromResponse(String response) {
        // 清理并标准化响应文本
        String cleanedResponse = response.trim().toUpperCase();

        // 尝试精确匹配意图关键词
        if (cleanedResponse.contains("KNOWLEDGE")) {
            return Intent.KNOWLEDGE;
        } else if (cleanedResponse.contains("CHIT_CHAT")) {
            return Intent.CHIT_CHAT;
        } else if (cleanedResponse.contains("SYSTEM")) {
            return Intent.SYSTEM;
        } else if (cleanedResponse.contains("SENSITIVE")) {
            return Intent.SENSITIVE;
        } else if (cleanedResponse.contains("UNCLEAR")) {
            return Intent.UNCLEAR;
        } else if (cleanedResponse.contains("OUT_OF_SCOPE")) {
            return Intent.OUT_OF_SCOPE;
        }

        // 无法识别时默认为知识型问题
        logger.warning("无法从响应中识别出意图: " + cleanedResponse + "，默认为 KNOWLEDGE");
        return Intent.KNOWLEDGE;
    }

    /**
     * 使用规则进行意图识别(备用方法)
     * @param question 用户问题
     * @return 识别出的意图
     */
    public Intent recognizeIntent(String question) {
        // 转换为小写以便匹配
        String lowercaseQuestion = question.toLowerCase();

        // 问候词模式匹配
        if (matchesPattern(lowercaseQuestion, "你好", "早上好", "晚上好", "下午好", "嗨", "hello", "hi", "hey")) {
            return Intent.CHIT_CHAT;
        }

        // 告别词模式匹配
        if (matchesPattern(lowercaseQuestion, "再见", "拜拜", "bye", "goodbye", "see you")) {
            return Intent.CHIT_CHAT;
        }

        // 感谢词模式匹配
        if (matchesPattern(lowercaseQuestion, "谢谢", "感谢", "thanks", "thank you", "thx")) {
            return Intent.CHIT_CHAT;
        }

        // 系统功能询问
        if (matchesPattern(lowercaseQuestion, "你是谁", "介绍自己", "你能做什么", "你的功能", "about you", "你叫什么", "你的名字")) {
            return Intent.SYSTEM;
        }

        // 默认为知识型问题
        return Intent.KNOWLEDGE;
    }

    /**
     * 辅助方法：检查文本是否包含任一模式
     */
    private boolean matchesPattern(String text, String... patterns) {
        for (String pattern : patterns) {
            if (text.contains(pattern)) {
                return true;
            }
        }
        return false;
    }
}

---
File: src\main\java\com\example\chatbot\service\KnowledgeService.java
---

package com.example.chatbot.service;

import com.example.chatbot.model.Document;
import com.example.chatbot.model.Segment;
import com.example.chatbot.repository.DocumentRepository;
import com.example.chatbot.repository.SegmentRepository;
import com.example.chatbot.util.DocumentParser;
import com.example.chatbot.util.TextUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 知识库管理服务：文件上传、存储、元数据入库
 */
@Service
public class KnowledgeService {

    private final DocumentRepository documentRepository;
    // 从配置注入目录
    private final Path uploadDir;
    private final SegmentRepository segmentRepo;
    private final EmbeddingService embeddingService;

    public KnowledgeService(DocumentRepository docRepo,
                            SegmentRepository segmentRepo,
                            EmbeddingService embeddingService,
                            @Value("${knowledge.upload-dir}") String uploadDir) throws IOException {
        this.documentRepository = docRepo;
        this.segmentRepo = segmentRepo;
        this.uploadDir = Paths.get(uploadDir).toAbsolutePath().normalize();
        this.embeddingService = embeddingService;
        // 如果目录不存在就创建
        Files.createDirectories(this.uploadDir);
    }

    /**
     * 上传并保存文件
     * @param file Spring MVC 接收的 MultipartFile
     * @return 保存后的 Document 元数据
     */
    public Document importFile(MultipartFile file) throws IOException {
        // 1. 原始文件名
        String originalFilename = file.getOriginalFilename();
        // 2. 目标文件路径：uploadDir/{timestamp}_{原名}
        String storedName = System.currentTimeMillis() + "_" + originalFilename;
        Path target = uploadDir.resolve(storedName);
        // 3. 保存到本地
        file.transferTo(target.toFile());

        // 4. 入库
        Document doc = new Document();
        doc.setFilename(originalFilename);
        doc.setFilepath(target.toString());
        doc.setUploadTime(LocalDateTime.now());
        return documentRepository.save(doc);
    }

    /**
     * 解析并分段入库
     */
    public void processDocument(Long docId) throws Exception {
        // 1. 查出文档元数据
        Document doc = documentRepository.findById(docId)
                .orElseThrow(() -> new IllegalArgumentException("找不到文档：" + docId));

        // 调试输出：查看路径
        System.out.println(">> 正在解析文档路径: " + doc.getFilepath());

        // 2. 解析为纯文本
        File file = new File(doc.getFilepath());
        System.out.println(">> 文件存在吗？ " + file.exists() + ", 大小 = " + file.length());
        String text = DocumentParser.parseToText(file);
        System.out.println(">> 解析后文本长度: " + text.length());
        System.out.println(">> 文本前 100 字: " + text.substring(0, Math.min(100, text.length())));

        // 3. 按 500 字拆分
        List<String> chunks = TextUtils.chunkText(text, 500);

        // 4. 保存每个片段
        for (String chunk : chunks) {
            Segment seg = new Segment();
            seg.setDocumentId(docId);
            seg.setContent(chunk);
            segmentRepo.save(seg);
            // 生成并存向量
            embeddingService.indexSegment(seg.getId(), chunk);
        }
    }
    
    /**
     * 上传文件并处理（一键上传、分段、建立索引）
     * @param file 要上传的文件
     * @return 文档元数据
     */
    public Document uploadAndProcess(MultipartFile file) {
        try {
            // 1. 上传并入库
            Document doc = importFile(file);
            
            // 2. 处理文档（分段、索引）
            processDocument(doc.getId());
            
            // 3. 返回处理后的文档元数据
            return doc;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("文件上传或处理失败: " + e.getMessage(), e);
        }
    }

    /**
     * 根据文档 ID 获取所有分段
     */
    public List<Segment> getAllSegmentsByDocumentId(Long documentId) {
        return segmentRepo.findByDocumentId(documentId);
    }

    /**
     * 获取所有知识库文档
     */
    public List<Document> getAllDocuments() {
        return documentRepository.findAll();
    }
}

---
File: src\main\java\com\example\chatbot\service\LLMService.java
---

package com.example.chatbot.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.logging.Logger;

/**
 * 语言模型服务：调用 Ollama REST API
 */
@Service
public class LLMService {
    private static final Logger logger = Logger.getLogger(LLMService.class.getName());
    // Ollama服务状态标志
    private boolean ollamaServiceAvailable = true;
    private long lastCheckTime = 0;
    private static final long CHECK_INTERVAL = 30000; // 30秒检查一次服务状态

    private final WebClient client;

    @Value("${ollama.model:gemma3:4b}")
    private String model;

    @Value("${chat.mode:local}")
    private String chatMode;
    
    @Value("${chatbot.prompt.system:你是一个有用的AI助手}")
    private String systemPrompt;
    
    @Value("${chatbot.prompt.preventHallucination:}")
    private String preventHallucinationPrompt;
    
    @Value("${chatbot.prompt.citation:}")
    private String citationPrompt;
    
    @Value("${chatbot.prompt.formatInstruction:}")
    private String formatInstruction;

    public LLMService(WebClient ollamaClient) {
        this.client = ollamaClient;
    }

    /**
     * 根据用户问题和相关知识片段生成回答
     * @param question 用户问题
     * @param relevantSegments 相关知识片段
     * @return 生成的回答
     */
    public String generateAnswer(String question, List<String> relevantSegments) {
        // 如果Ollama服务不可用且在检查间隔内，直接返回离线回复
        if (!shouldTryConnectingToOllama()) {
            return getFallbackResponse(question);
        }

        try {
            // 将相关段落合并成一个上下文
            String context = relevantSegments.isEmpty() 
                ? "没有找到相关的知识库内容。" 
                : relevantSegments.stream()
                    .map(seg -> seg.trim())
                    .collect(Collectors.joining("\n\n"));
                    
            // 构建RAG提示词
            String fullPrompt = String.format(
                "%s\n\n" +
                "%s\n\n" + 
                "%s\n\n" +
                "%s\n\n" +
                "知识库内容：\n%s\n\n" +
                "用户问题：%s\n\n助手回答：",
                systemPrompt,
                preventHallucinationPrompt,
                citationPrompt,
                formatInstruction,
                context,
                question
            );

            logger.info("调用 LLM 生成回复，包含对话上下文，提示词长度: " + fullPrompt.length());

            // 构造请求体
            Map<String, Object> req = Map.of(
                    "model", model,
                    "prompt", fullPrompt,
                    "stream", false
            );

            // 发送请求
            Map<String, Object> resp = client.post()
                    .uri("/api/generate")
                    .bodyValue(req)
                    .retrieve()
                    .bodyToMono(Map.class)
                    .timeout(Duration.ofSeconds(60))
                    .block();

            // 服务连接成功，更新状态
            ollamaServiceAvailable = true;

            if (resp == null) {
                return "LLM 服务未返回有效响应";
            }

            // 提取回复文本
            String response = (String) resp.get("response");
            if (response != null) {
                System.out.println(">> 成功获取回复，长度: " + response.length());
                return response;
            }

            return "无法解析 LLM 返回的响应格式";
        } catch (WebClientRequestException e) {
            // 标记服务不可用
            ollamaServiceAvailable = false;
            lastCheckTime = System.currentTimeMillis();
            logger.severe("无法连接到Ollama服务: " + e.getMessage());
            return getFallbackResponse(question);
        } catch (Exception e) {
            logger.severe("调用 LLM 服务失败: " + e.getMessage());
            e.printStackTrace();
            return "服务调用出错: " + e.getMessage();
        }
    }

    /**
     * 根据用户问题、相关知识片段和对话历史生成回答
     * @param question 用户问题
     * @param relevantSegments 相关知识片段
     * @param conversationContext 对话历史上下文
     * @return 生成的回答
     */
    public String generateAnswerWithContext(String question, List<String> relevantSegments, String conversationContext) {
        // 如果Ollama服务不可用且在检查间隔内，直接返回离线回复
        if (!shouldTryConnectingToOllama()) {
            return getFallbackResponse(question);
        }

        try {
            // 将相关段落合并成一个上下文
            String context = relevantSegments.isEmpty()
                    ? "没有找到相关的知识库内容。"
                    : relevantSegments.stream()
                    .map(seg -> seg.trim())
                    .collect(Collectors.joining("\n\n"));

            // 构建RAG提示词，加入对话历史
            String fullPrompt = String.format(
                    "%s\n\n" +
                            "%s\n\n" +
                            "%s\n\n" +
                            "%s\n\n" +
                            "%s" + // 对话历史上下文（如果有）
                            "知识库内容：\n%s\n\n" +
                            "用户当前问题：%s\n\n助手回答：",
                    systemPrompt,
                    preventHallucinationPrompt,
                    citationPrompt,
                    formatInstruction,
                    conversationContext, // 可能为空
                    context,
                    question
            );

            logger.info("调用 LLM 生成回复，包含对话上下文，提示词以及历史对话，总长度: " + fullPrompt.length());

            // 构造请求体
            Map<String, Object> req = Map.of(
                    "model", model,
                    "prompt", fullPrompt,
                    "stream", false
            );

            // 发送请求
            Map<String, Object> resp = client.post()
                    .uri("/api/generate")
                    .bodyValue(req)
                    .retrieve()
                    .bodyToMono(Map.class)
                    .timeout(Duration.ofSeconds(60))
                    .block();

            // 服务连接成功，更新状态
            ollamaServiceAvailable = true;

            if (resp == null) {
                return "LLM 服务未返回有效响应";
            }

            // 提取回复文本
            String response = (String) resp.get("response");
            if (response != null) {
                logger.info("成功获取带上下文的回复，长度: " + response.length());
                logger.info("内容：\n" + response);
                return response;
            }

            return "无法解析 LLM 返回的响应格式";
        }catch (WebClientRequestException e) {
            // 标记服务不可用
            ollamaServiceAvailable = false;
            lastCheckTime = System.currentTimeMillis();
            logger.severe("无法连接到Ollama服务: " + e.getMessage());
            return getFallbackResponse(question);
        } catch (Exception e) {
            logger.severe("调用带上下文的 LLM 服务失败: " + e.getMessage());
            e.printStackTrace();
            return "服务调用出错: " + e.getMessage();
        }
    }

    @SuppressWarnings("unchecked")
    public String generateResponse(String userQuestion) {
        // 如果Ollama服务不可用且在检查间隔内，直接返回离线回复
        if (!shouldTryConnectingToOllama()) {
            return getFallbackResponse(userQuestion);
        }

        try {
            // 构建更完善的提示词
            String fullPrompt = String.format(
                "你是一个有用的AI助手，请用中文回答以下问题，给出详细的解释：\n\n用户问题：%s\n\n助手回答：",
                userQuestion
            );

            logger.info("调用 LLM 生成简单回复，提示词长度: " + fullPrompt.length());

            // 构造请求体
            Map<String, Object> req = Map.of(
                    "model", model,
                    "prompt", fullPrompt,
                    "stream", false
            );

            // 发送请求
            Map<String, Object> resp = client.post()
                    .uri("/api/generate")
                    .bodyValue(req)
                    .retrieve()
                    .bodyToMono(Map.class)
                    .timeout(Duration.ofSeconds(60))
                    .block();

            // 服务连接成功，更新状态
            ollamaServiceAvailable = true;

            if (resp == null) {
                return "LLM 服务未返回有效响应";
            }

            // 提取回复文本
            String response = (String) resp.get("response");
            if (response != null) {
                logger.info("成功获取简单回复，长度: " + response.length());
                return response;
            }

            return "无法解析 LLM 返回的响应格式";
        } catch (WebClientRequestException e) {
            // 标记服务不可用
            ollamaServiceAvailable = false;
            lastCheckTime = System.currentTimeMillis();
            logger.severe("无法连接到Ollama服务: " + e.getMessage());
            return getFallbackResponse(userQuestion);
        } catch (Exception e) {
            logger.severe("调用 LLM 服务失败: " + e.getMessage());
            e.printStackTrace();
            return "服务调用出错: " + e.getMessage();
        }
    }

    /**
     * 离线回复，当Ollama服务不可用时使用
     */
    private String getFallbackResponse(String question) {
        logger.info("生成离线回复，因为Ollama服务不可用");

        // 根据问题内容提供基本回复
        if (question.contains("你好") || question.contains("嗨") || question.contains("hi") || question.contains("hello")) {
            return "您好！我是AI助手。目前我正在离线模式下运行，某些功能可能受限。";
        } else if (question.contains("谢谢") || question.contains("感谢") || question.contains("thanks")) {
            return "不客气！很高兴能帮到您。目前我正在离线模式下运行，如有更多需求，可能需要等待在线服务恢复。";
        } else if (question.contains("再见") || question.contains("拜拜") || question.contains("bye")) {
            return "再见！如有需要随时回来咨询。";
        } else if (question.contains("帮助") || question.contains("help") || question.contains("怎么用")) {
            return "我是一个AI助手，可以回答问题和提供信息。目前我正在离线模式下运行，功能受限。正常情况下我可以回答知识性问题、提供建议等。";
        } else {
            return "抱歉，目前AI服务暂时不可用，无法回答您的问题。请确认Ollama服务是否已启动（默认端口11434），或稍后再试。";
        }
    }

    /**
     * 判断是否应该尝试连接Ollama服务
     */
    private boolean shouldTryConnectingToOllama() {
        // 如果服务可用，始终返回true
        if (ollamaServiceAvailable) {
            return true;
        }

        // 如果服务不可用，但已经超过了检查间隔，尝试重新连接
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastCheckTime > CHECK_INTERVAL) {
            logger.info("尝试重新连接Ollama服务...");
            return true;
        }

        // 服务不可用且在检查间隔内，不尝试连接
        return false;
    }

    private String remoteChat(String prompt) {
        // TODO: 实现 OpenAI/DeepSeek 调用
        return "【远程 API 占位回答】";
    }
}

---
File: src\main\java\com\example\chatbot\service\UserService.java
---

package com.example.chatbot.service;

import com.example.chatbot.model.User;
import com.example.chatbot.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * 用户业务逻辑层，封装对 UserRepository 的调用
 */
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    /** 创建新用户 */
    public User createUser(User user) {
        return userRepository.save(user);
    }

    /** 查询所有用户 */
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    /** 根据 ID 查询用户 */
    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }

    /** 更新用户信息 */
    public Optional<User> updateUser(Long id, User updated) {
        return userRepository.findById(id)
                .map(existing -> {
                    existing.setUsername(updated.getUsername());
                    existing.setPassword(updated.getPassword());
                    return userRepository.save(existing);
                });
    }

    /** 删除用户 */
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}


---
File: src\main\java\com\example\chatbot\util\DocumentParser.java
---

package com.example.chatbot.util;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;

/**
 * 文档解析工具：将 txt/pdf/docx 转为纯文本
 */
public class DocumentParser {

    /** 读取 txt 文件内容 */
    public static String parseTxt(File file) throws IOException {
        return new String(Files.readAllBytes(file.toPath()), "UTF-8");
    }

    /** 读取 PDF 文件内容 */
    public static String parsePdf(File file) throws IOException {
        try (PDDocument pdf = PDDocument.load(file)) {
            PDFTextStripper stripper = new PDFTextStripper();
            return stripper.getText(pdf);
        }
    }

    /** 读取 DOCX 文件内容 */
    public static String parseDocx(File file) throws IOException {
        try (FileInputStream fis = new FileInputStream(file);
             XWPFDocument doc = new XWPFDocument(fis)) {
            StringBuilder sb = new StringBuilder();
            for (XWPFParagraph p : doc.getParagraphs()) {
                sb.append(p.getText()).append("\n");
            }
            return sb.toString();
        }
    }

    /**
     * 根据文件后缀，自动选择解析方法
     * @param file 本地 File 对象
     */
    public static String parseToText(File file) throws IOException {
        String name = file.getName().toLowerCase();
        if (name.endsWith(".txt")) {
            return parseTxt(file);
        } else if (name.endsWith(".pdf")) {
            return parsePdf(file);
        } else if (name.endsWith(".docx")) {
            return parseDocx(file);
        } else {
            throw new UnsupportedOperationException("不支持的文件格式：" + name);
        }
    }
}


---
File: src\main\java\com\example\chatbot\util\TextUtils.java
---

package com.example.chatbot.util;

import java.util.ArrayList;
import java.util.List;

/**
 * 文本工具：将长文本拆分成多个短片段
 */
public class TextUtils {

    /**
     * 按最大长度切分文本，不按单词边界，简单粗暴。
     * @param text 原始文本
     * @param chunkSize 每块最大字符数，例如 500
     */
    public static List<String> chunkText(String text, int chunkSize) {
        List<String> chunks = new ArrayList<>();
        int length = text.length();
        for (int start = 0; start < length; start += chunkSize) {
            int end = Math.min(length, start + chunkSize);
            chunks.add(text.substring(start, end));
        }
        return chunks;
    }
}


---
File: src\main\resources\static\app.js
---

// 当整个HTML文档加载完成后，执行这个函数
document.addEventListener('DOMContentLoaded', function() {
    // 获取页面上的HTML元素，以便后续操作它们
    // getElementById是用来根据HTML元素的id属性找到对应元素的方法
    const chatContainer = document.getElementById('chatContainer'); // 聊天内容显示区域
    const userInput = document.getElementById('userInput');         // 用户输入框
    const sendBtn = document.getElementById('sendBtn');             // 发送按钮
    const uploadForm = document.getElementById('uploadForm');       // 上传文件的表单
    const fileInput = document.getElementById('fileInput');         // 文件选择输入框
    const uploadBtn = document.getElementById('uploadBtn');         // 上传按钮
    const uploadStatus = document.getElementById('uploadStatus');   // 上传状态显示区域
    const fileList = document.getElementById('fileList');           // 文件列表显示区域

    // 页面加载时，调用函数加载已上传的知识库文件列表
    loadFileList();

    // 为发送按钮添加点击事件监听器，当用户点击时调用sendMessage函数
    sendBtn.addEventListener('click', sendMessage);
    
    // 为输入框添加键盘事件监听器，当用户按下Enter键且没有同时按Shift键时发送消息
    userInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault(); // 阻止默认行为（换行）
            sendMessage();      // 调用发送消息函数
        }
    });

    // 为上传表单添加提交事件监听器，阻止默认提交行为，改为调用uploadFile函数
    uploadForm.addEventListener('submit', function(e) {
        e.preventDefault();     // 阻止表单默认提交行为（页面刷新）
        uploadFile();           // 调用上传文件函数
    });

    // 发送聊天消息的函数
    function sendMessage() {
        // 获取用户输入的消息内容并去除两端空格
        const message = userInput.value.trim();
        // 如果消息为空，则不做任何操作
        if (!message) return;

        // 将用户消息添加到聊天容器中显示
        appendMessage(message, 'user');
        // 清空输入框
        userInput.value = '';

        // 创建"正在思考"的提示元素
        const typingIndicator = document.createElement('div');
        // 设置元素的CSS类，用于样式应用
        typingIndicator.className = 'system-message typing-indicator';
        // 设置元素的文本内容
        typingIndicator.textContent = '正在思考...';
        // 将元素添加到聊天容器中
        chatContainer.appendChild(typingIndicator);
        // 滚动聊天容器到底部，显示最新消息
        chatContainer.scrollTop = chatContainer.scrollHeight;

        // 使用fetch API调用后端接口，发送用户问题
        fetch('/api/chat', {
            method: 'POST',                           // HTTP请求方法：POST
            headers: {
                'Content-Type': 'application/json'    // 设置请求头，说明发送的是JSON数据
            },
            body: JSON.stringify({ question: message })  // 将消息对象转为JSON字符串作为请求体
        })
            .then(response => {
                // 检查HTTP响应状态
                if (!response.ok) {
                    throw new Error('网络响应异常');  // 如果状态不是成功，抛出错误
                }
                return response.json();  // 将响应解析为JSON
            })
            .then(data => {
                // 移除"正在思考"的提示元素
                chatContainer.removeChild(typingIndicator);
                // 将系统回复添加到聊天容器
                appendMessage(data.answer, 'system');
            })
            .catch(error => {
                // 捕获并处理任何错误
                console.error('发送消息出错:', error);  // 在控制台记录错误
                // 移除"正在思考"的提示元素
                chatContainer.removeChild(typingIndicator);
                // 显示友好的错误消息给用户
                appendMessage('抱歉，服务器暂时无法响应，请稍后再试。', 'system');
            });
    }

    // 将消息添加到聊天容器的函数
    function appendMessage(message, sender) {
        // 创建一个新的div元素来容纳消息
        const messageElement = document.createElement('div');
        // 根据消息发送者设置不同的CSS类名
        messageElement.className = sender === 'user' ? 'user-message' : 'system-message';

        // 支持简单的Markdown格式转换为HTML
        let formattedMessage = message
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // 将**文本**转换为粗体
            .replace(/\n- /g, '<br>• ')                        // 将换行后的"-"转换为项目符号
            .replace(/\n/g, '<br>');                           // 将换行符转换为HTML换行标签

        // 设置消息元素的HTML内容
        messageElement.innerHTML = formattedMessage;
        // 将消息元素添加到聊天容器
        chatContainer.appendChild(messageElement);
        // 滚动聊天容器到底部，显示最新消息
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // 上传知识库文件的函数
    function uploadFile() {
        // 获取用户选择的文件
        const file = fileInput.files[0];
        // 如果没有选择文件，显示错误信息并返回
        if (!file) {
            uploadStatus.textContent = '请选择文件';
            uploadStatus.style.color = 'red';
            return;
        }

        // 创建FormData对象，用于发送文件
        const formData = new FormData();
        // 将文件添加到FormData中
        formData.append('file', file);

        // 更新上传状态显示
        uploadStatus.textContent = '上传中...';
        uploadStatus.style.color = '#333';

        // 使用fetch API调用后端上传接口
        fetch('/api/knowledge/upload', {
            method: 'POST',     // HTTP请求方法：POST
            body: formData      // 直接发送FormData对象作为请求体
        })
            .then(response => {
                // 检查HTTP响应状态
                if (!response.ok) {
                    throw new Error('文件上传失败');  // 如果状态不是成功，抛出错误
                }
                return response.json();  // 将响应解析为JSON
            })
            .then(data => {
                // 上传成功，更新状态显示
                uploadStatus.textContent = '文件上传成功!';
                uploadStatus.style.color = 'green';
                // 清空文件选择输入框
                fileInput.value = '';
                // 刷新文件列表
                loadFileList();
            })
            .catch(error => {
                // 捕获并处理任何错误
                console.error('上传出错:', error);  // 在控制台记录错误
                // 显示错误消息
                uploadStatus.textContent = '上传失败: ' + error.message;
                uploadStatus.style.color = 'red';
            });
    }

    // 加载知识库文件列表的函数
    function loadFileList() {
        // 使用fetch API调用后端获取文件列表接口
        fetch('/api/knowledge/files')
            .then(response => {
                // 检查HTTP响应状态
                if (!response.ok) {
                    throw new Error('获取文件列表失败');  // 如果状态不是成功，抛出错误
                }
                return response.json();  // 将响应解析为JSON
            })
            .then(data => {
                // 清空当前文件列表
                fileList.innerHTML = '';
                // 检查文件列表是否为空
                if (data.length === 0) {
                    // 如果为空，显示"暂无上传文件"
                    const emptyItem = document.createElement('li');
                    emptyItem.textContent = '暂无上传文件';
                    fileList.appendChild(emptyItem);
                } else {
                    // 如果不为空，遍历文件列表并显示每个文件
                    data.forEach(file => {
                        const item = document.createElement('li');
                        // 设置列表项的文本为文件名和上传时间
                        item.textContent = `${file.filename} (${formatDate(file.uploadTime)})`;
                        // 将列表项添加到文件列表
                        fileList.appendChild(item);
                    });
                }
            })
            .catch(error => {
                // 捕获并处理任何错误
                console.error('获取文件列表失败:', error);  // 在控制台记录错误
                // 显示错误消息
                fileList.innerHTML = '<li>获取文件列表失败</li>';
            });
    }

    // 格式化日期的函数
    function formatDate(dateString) {
        // 创建一个Date对象
        const date = new Date(dateString);
        // 使用toLocaleString方法格式化日期
        return date.toLocaleString('zh-CN', {
            year: 'numeric',    // 显示年份（数字）
            month: '2-digit',   // 显示月份（两位数）
            day: '2-digit',     // 显示日期（两位数）
            hour: '2-digit',    // 显示小时（两位数）
            minute: '2-digit'   // 显示分钟（两位数）
        });
    }
});

---
File: src\main\resources\static\index.html
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能客服系统</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="container">
    <header>
        <h1>智能客服系统</h1>
    </header>

    <main>
        <div class="chat-section">
            <div class="chat-container" id="chatContainer">
                <!-- 聊天消息将在这里动态显示 -->
                <div class="system-message">
                    您好，我是智能客服助手，有什么可以帮您解答的问题吗？
                </div>
            </div>

            <div class="input-container">
                <textarea id="userInput" placeholder="请输入您的问题..." rows="2"></textarea>
                <button id="sendBtn">发送</button>
            </div>
        </div>

        <div class="sidebar">
            <div class="upload-section">
                <h3>上传知识库文件</h3>
                <form id="uploadForm">
                    <input type="file" id="fileInput" accept=".txt,.pdf,.docx,.doc">
                    <button type="submit" id="uploadBtn">上传文件</button>
                </form>
                <div id="uploadStatus"></div>
            </div>

            <div class="file-list-section">
                <h3>已上传文件</h3>
                <ul id="fileList">
                    <!-- 已上传的文件将在这里显示 -->
                </ul>
            </div>
        </div>
    </main>
</div>

<script src="app.js"></script>
</body>
</html>

---
File: src\main\resources\static\styles.css
---

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    margin-bottom: 20px;
}

main {
    display: flex;
    gap: 20px;
}

.chat-section {
    flex: 3;
    display: flex;
    flex-direction: column;
    height: 80vh;
}

.sidebar {
    flex: 1;
    background-color: #fff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

.chat-container {
    flex: 1;
    background-color: #fff;
    padding: 15px;
    border-radius: 8px 8px 0 0;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    overflow-y: auto;
    margin-bottom: 5px;
}

.input-container {
    display: flex;
    background-color: #fff;
    padding: 10px;
    border-radius: 0 0 8px 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

textarea {
    flex: 1;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: none;
    font-family: inherit;
}

button {
    padding: 10px 15px;
    background-color: #4caf50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-left: 10px;
}

button:hover {
    background-color: #388e3c;
}

.user-message, .system-message {
    margin-bottom: 15px;
    padding: 10px 15px;
    border-radius: 18px;
    max-width: 80%;
    word-wrap: break-word;
}

.user-message {
    background-color: #e3f2fd;
    margin-left: auto;
    border-bottom-right-radius: 5px;
}

.system-message {
    background-color: #f1f1f1;
    margin-right: auto;
    border-bottom-left-radius: 5px;
}

.upload-section, .file-list-section {
    margin-bottom: 20px;
}

.upload-section h3, .file-list-section h3 {
    margin-bottom: 10px;
}

input[type="file"] {
    margin-bottom: 10px;
    width: 100%;
}

#uploadBtn {
    width: 100%;
}

#uploadStatus {
    margin-top: 10px;
    font-size: 14px;
}

#fileList {
    list-style: none;
}

#fileList li {
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}

---
File: src\test\java\com\example\chatbot\LlmSystemApplicationTests.java
---

package com.example.chatbot;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class LlmSystemApplicationTests {

	@Test
	void contextLoads() {
	}

}


---
File: src\test\java\com\example\chatbot\service\IntentRecognitionServiceTest.java
---

package com.example.chatbot.service;

import com.example.chatbot.service.IntentRecognitionService.Intent;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

/**
 * 意图识别服务测试类
 */
public class IntentRecognitionServiceTest {

    @Mock
    private LLMService llmService;

    @InjectMocks
    private IntentRecognitionService intentRecognitionService;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testRecognizeIntent_ChitChat_Greeting() {
        // 测试问候意图
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("你好"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("早上好啊"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("嗨，最近怎么样？"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("Hello there!"));
    }

    @Test
    public void testRecognizeIntent_ChitChat_Farewell() {
        // 测试告别意图
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("再见"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("拜拜，下次聊"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("Goodbye, see you later"));
    }

    @Test
    public void testRecognizeIntent_ChitChat_Thanks() {
        // 测试感谢意图
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("谢谢你的帮助"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("非常感谢"));
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntent("Thank you so much"));
    }

    @Test
    public void testRecognizeIntent_System_Help() {
        // 测试系统帮助请求意图
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntent("我需要帮助"));
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntent("怎么用这个系统？"));
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntent("Can you help me?"));
    }

    @Test
    public void testRecognizeIntent_Knowledge() {
        // 测试知识查询意图
        assertEquals(Intent.KNOWLEDGE, intentRecognitionService.recognizeIntent("什么是人工智能？"));
        assertEquals(Intent.KNOWLEDGE, intentRecognitionService.recognizeIntent("如何学习编程？"));
        assertEquals(Intent.KNOWLEDGE, intentRecognitionService.recognizeIntent("为什么天空是蓝色的？"));
    }

    @Test
    public void testRecognizeIntent_System_Identity() {
        // 测试系统身份询问
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntent("你是谁"));
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntent("介绍一下自己"));
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntent("你叫什么名字"));
    }

    @Test
    public void testRecognizeIntent_Unknown() {
        // 测试未知意图（默认为KNOWLEDGE）
        assertEquals(Intent.KNOWLEDGE, intentRecognitionService.recognizeIntent("xyz123"));
        assertEquals(Intent.KNOWLEDGE, intentRecognitionService.recognizeIntent("随机文本"));
    }

    @Test
    public void testRecognizeIntentWithLLM() {
        // 模拟LLM返回的意图
        when(llmService.generateResponse(anyString())).thenReturn("CHIT_CHAT");

        // 测试LLM意图识别
        assertEquals(Intent.CHIT_CHAT, intentRecognitionService.recognizeIntentWithLLM("你好吗？"));

        // 模拟LLM返回系统意图
        when(llmService.generateResponse(anyString())).thenReturn("SYSTEM");
        assertEquals(Intent.SYSTEM, intentRecognitionService.recognizeIntentWithLLM("你是谁？"));

        // 模拟LLM返回无效意图，应该默认为知识型问题
        when(llmService.generateResponse(anyString())).thenReturn("INVALID_INTENT");
        assertEquals(Intent.KNOWLEDGE, intentRecognitionService.recognizeIntentWithLLM("随机问题"));
    }
}

